import numpy as np

import obsLE.process_data as data_proc
import obsLE.transform as transform
import obsLE.optimize as optim
import obsLE.fit_model as fit
import obsLE.resample as resample


def build_obsLE(beta_ds,
                residuals_da,
                block_size,
                surrogate_modes,
                mode_list,
                lam,
                offset,
                save_path,
                forcing_df=None):
    """
    Build Observational Large Ensemble (Obs-LE) members from the fitted regression 
    coefficients and the residuals.

    Parameters
    ----------
    beta_ds: xr.Dataset, dims: (month, lat, lon)
        Dataset containing the fitted beta coefficients from the linear models
        for each climate mode fitted for each month and location. These coefficients
        are held fixed in the Obs-LE. See fit_model.fit_linear_model() and 
        fit_model.build_model_ds() for additional details.
        
    residuals_da: xr.DataArray, dims: (time, lat, lon)
        DataArray containing the residuals from the fitted linear models.

    block_size: int
        Integer giving the block size in months for the moving block bootstrap. 
        Must be divisible by 12 to ensure that whole years are included, 
        preserving seasonality.
        
    surrogate_modes: np.ndarray, dims: (n_ensemble_members, n_climate_modes, n_time)
        Numpy array containing the surrogate climate modes generated by IAAFT. See
        resample.iaaft() for more details. The first dimension contains different
        sets of surrogate climate modes, the second dimension indexes the climate 
        mode, and the last dimension indexes the time series time index.
        
    mode_list: list of str
        list containing the names of the climate modes. Names should match the
        variable names in beta_ds, and the order should match the order in
        surrogate_modes.

    forcing_df: pd.DataFrame, dims: (n_time, n_forcing_ts)
        DataFrame containing the forcing time series as columns. Names should match
        the names in beta_ds and the index should be a pd.datetime64 matching the
        residuals time coordinate.

    lam: xr.DataArray, dims: (month, lat, lon)
        DataArray containing the power paramter, lambda, of the Box-Cox transform.
        Used for transforming the newly generated values back into the original
        precipitation space. See transform.inv_boxcox_transform() for details.

    offset: xr.DataArray, dims: (month, lat, lon)
        DataArray containing the offset parameter of the Box-Cox transform. Used
        for transforming teh newly generated values back into the original 
        precipitation space. See transform.inv_boxcox_transform() for details.

    save_path: str
        Path to the directory for saving the outputted ensemble members. Directory
        name should end in /. Members are saved in netCDF file format at:
        save_path + 'obsLE_member{member #}.nc'.

    Returns
    -------
    None
    """

    n_ens = surrogate_modes.shape[0]
    
    mode_index = np.searchsorted(beta_ds.month, residuals_da['time.month'])

    base_mean_field = beta_ds['intercept'][mode_index]

    if forcing_df is not None:
        forcings_list = forcing_df.columns.to_list()

        for forcing in forcings_list:
            beta_forcing = beta_ds[forcing]
            # add axes to the forcing for numpy broadcasting with lon, lat dimensions
            forcing_ts = forcing_df[forcing].values[:, np.newaxis, np.newaxis]
            forcing_field = beta_forcing[mode_index].values * forcing_ts
            base_mean_field = base_mean_field + forcing_field

    for k in range(n_ens):
        bootstrap_residuals = resample.bootstrap_residuals(residuals_da,
                                                           block_size=block_size)
    
        surrogate_mat = np.transpose(surrogate_modes[k])
    
        p = surrogate_mat.shape[1]
        n = surrogate_mat.shape[0]

        mean_field = base_mean_field
    
        for j in range(p):
            surrogate_ts = surrogate_mat[:, j].reshape((n, 1, 1))
            beta_mode = beta_ds[mode_list[j]]
    
            mean_field = mean_field + beta_mode[mode_index].values * surrogate_ts
    
        mean_field = mean_field.rename({'month': 'time'})
        mean_field = mean_field.assign_coords({'time': residuals_da.time})
    
        obsLE_member = mean_field + bootstrap_residuals
    
        obsLE_member = transform.inv_boxcox_transform(obsLE_member,
                                                      offset=offset,
                                                      lam=lam)
        
        member_savename = save_path + f'obsLE_member{k + 1:04}.nc'

        obsLE_member.to_netcdf(member_savename)

def obsLE_pipeline(n_ens_members,
                   y,
                   start_year,
                   end_year,
                   mode_list,
                   lambda_values,
                   offset_values,
                   fit_seasonal,
                   block_size,
                   save_path,
                   mode_df=None,
                   forcing_df=None,
                   mode_path=None):
    """Construct the Observational Large Ensemble (Obs-LE).
    
    Parameters
    ----------
    n_ens_members, int
        number of ensemble members to build.

    target_da, xr.DataArray, dims: (time, lat, lon)
        DataArray containing the target variable for building the Obs-LE.

    mode_df: pd.DataFrame
        DataFrame containing the climate modes as columns. The index should be 
        a pd.datetime64 index. Rows should contain monthly observations of the
        climate modes. If None, imports modes using 
        process_data.process_climate_modes().

    start_year: str
        First year to include in the Obs-LE. String with four digit year.

    end_year: str
        Last year to include in the Obs-LE. String with four digit year.

    mode_list: list of str
        list containing the names of the climate modes to include.

    lambda_values: list of numeric
         List containing Box-Cox power paramters to optimize over for the
         transformation applied to target_da. Values for the transform are 
         restricted to be positive.

    offset_values: list of numeric
        List containing offsets to be optimized over for shifting target_da before
        apply Box-Cox transform. If there are zeros in the data, offset_values 
        should be positive values such that target_da + offset_values is positive 
        everywhere. Selecting a single value such as [1e-6] works well in practice.

    fit_seasonal: list of bools
        True/False values with length = len(mode_list). True specifies that the
        seasonal cycle in the variance should be maintained in the surrogate modes.
        For most climate modes, fit_seasonal should be True, since there can be
        large differences in variance between months. The trade-off is an increased
        number of iterations before IAAFT converges.

    block_size: int
        The length of time blocks, in months, to use for the moving block bootstrap.
        Must be divisible by 12, so that only whole years are included.

    save_path: str
        Path to the directory in which to save the outputted Obs-LE members and 
        component files. Should end in /. Individual members are saved as 
        netCDF files at: save_path + 'obsLE_member{member #}.nc'

    mode_path: str
        path to the climate modes
    """
    if mode_df is None and mode_path is None:
        raise ValueError('One of mode_df or mode_path must be specified')
    
    ortho_mode_df = data_proc.build_ortho_mode_df(mode_df=mode_df,
                                                  start_year=start_year,
                                                  end_year=end_year,
                                                  mode_list=mode_list,
                                                  save_path=save_path,
                                                  mode_path=mode_path)

    if forcing_df is not None:
        X = ortho_mode_df.merge(forcing_df, on='time')
    else:
        X = ortho_mode_df
    
    param_ds, llik_ds = optim.optimize_transform(y=y,
                                                 X=X,
                                                 lambda_values=lambda_values,
                                                 offset_values=offset_values,
                                                 save_path=save_path)
    
    beta, lm_out = fit.fit_optimized_model(y=y,
                                           X=X,
                                           lam=param_ds['lam'],
                                           offset=param_ds['offset'],
                                           save_path=save_path)

    residuals_da = lm_out['residuals']

    surrogate_modes = resample.create_surrogate_modes(ortho_mode_df,
                                                      fit_seasonal=fit_seasonal,
                                                      n_ens_members=n_ens_members)[0]

    
    build_obsLE(beta_ds=beta, 
                residuals_da=residuals_da,
                block_size=block_size,
                surrogate_modes=surrogate_modes,
                mode_list=mode_list,
                lam=param_ds['lam'],
                offset=param_ds['offset'],
                forcing_df=forcing_df,
                save_path=save_path)
