import numpy as np
import warnings

from . import process_data as data_proc
from . import transform as transform
from . import optimize as optim
from . import fit_model as fit
from . import resample as resample


def build_obsLE(beta_ds,
                residuals_da,
                block_size,
                surrogate_modes,
                lam,
                offset,
                save_path,
                forcing_df=None,
                rng=None):
    """
    Build Observational Large Ensemble (Obs-LE) members from the fitted regression 
    coefficients and the residuals.

    Parameters
    ----------
    beta_ds : xr.Dataset, dims: (month, lat, lon)
        Dataset containing the fitted beta coefficients from the linear models
        for each climate mode fitted for each month and location. These coefficients
        are held fixed in the Obs-LE. See fit_model.fit_linear_model() and 
        fit_model.build_model_ds() for additional details.
        
    residuals_da : xr.DataArray, dims: (time, lat, lon)
        DataArray containing the residuals from the fitted linear models.

    block_size : int
        Integer giving the block size in months for the moving block bootstrap. 
        Must be divisible by 12 to ensure that whole years are included, 
        preserving seasonality.
        
    surrogate_modes : xr.Dataset, dims: (n_ensemble_members, n_time)
        Dataset containing the surrogate climate modes generated by IAAFT as
        variables. See resample.iaaft() and resample.create_surrogate_modes() 
        for more details. 

    lam : xr.DataArray, dims: (month, lat, lon)
        DataArray containing the power paramter, lambda, of the Box-Cox transform.
        Used for transforming the newly generated values back into the original
        precipitation space. See transform.inv_boxcox_transform() for details.

    offset : xr.DataArray, dims: (month, lat, lon)
        DataArray containing the offset parameter of the Box-Cox transform. Used
        for transforming the newly generated values back into the original 
        precipitation space. See transform.inv_boxcox_transform() for details.

    save_path : str
        Path to the directory for saving the outputted ensemble members. Directory
        name should end in /. Members are saved in netCDF file format at:
        save_path + 'obsLE_member{member #}.nc'.

    forcing_df : pd.DataFrame, dims: (n_time, n_forcing_ts)
        DataFrame containing the forcing time series as columns. Names should match
        the names in beta_ds and the index should be a pd.datetime64 matching the
        residuals time coordinate.

    rng : Numpy random generator
        Like numpy.random.default_rng(seed). Used to produce pseudo-random numbers.

    Returns
    -------
    None

    """
    if rng is None:
        rng = np.random.default_rng()

    nan_mask = residuals_da.isnull().any('time')

    mode_list = list(surrogate_modes.data_vars.keys())

    ens_members = surrogate_modes['ens_member'].values
    month_seq = residuals_da['time.month']

    base_mean_field = beta_ds['intercept'].loc[{'month': month_seq}]

    beta_ts_list = [beta_ds[mode].loc[{'month': month_seq}] 
        for mode 
        in mode_list]
    
    beta_ts_dict = dict(zip(mode_list, beta_ts_list))

    if forcing_df is not None:
        if not forcing_df.index.equals(residuals_da.indexes['time']):
            warnings.warn('forcing_df and residuals_da have different time indices. '
            'This may results in incorrect alignment of residuals and forcings.')

        forcings_list = forcing_df.columns.to_list()

        for forcing in forcings_list:
            beta_forcing = beta_ds[forcing].loc[{'month': month_seq}]
            # add axes to the forcing for numpy broadcasting with lon, lat dimensions
            forcing_ts = forcing_df[forcing].to_xarray()
            force_field = beta_forcing * forcing_ts
            base_mean_field = base_mean_field + force_field

    for mem in ens_members:
        bootstrap_residuals = resample.bootstrap_residuals(residuals_da,
                                                           block_size=block_size,
                                                           rng=rng)
        
        surrogate_member = surrogate_modes.sel(ens_member=mem)

        mean_field = base_mean_field

        for mode in mode_list:
            surrogate_ts = surrogate_member[mode]
            beta_mode_ts = beta_ts_dict[mode]
    
            mean_field = mean_field + beta_mode_ts * surrogate_ts

        mean_field = mean_field.drop_vars('month')

        obsLE_member = mean_field + bootstrap_residuals
        # precip must be non-negative in transformed space.
        obsLE_member = (obsLE_member
            .where(obsLE_member >= 0, 0)
            .where(nan_mask))
    
        obsLE_member = transform.inv_boxcox_transform(obsLE_member,
                                                      offset=offset,
                                                      lam=lam)

        obsLE_member = obsLE_member.rename('var')
        
        member_savename = save_path + f'obsLE_member{mem + 1:04}.nc'
        obsLE_member.to_netcdf(member_savename)


def obsLE_pipeline(n_ens_members,
                   y,
                   start_year,
                   end_year,
                   mode_list,
                   lambda_values,
                   offset_values,
                   fit_seasonal,
                   block_size,
                   save_path,
                   rng=None,
                   mode_df=None,
                   forcing_df=None,
                   mode_path=None):
    """Construct the Observational Large Ensemble (Obs-LE).
    
    Parameters
    ----------
    n_ens_members, int
        number of ensemble members to build.

    y, xr.DataArray, dims: (time, lat, lon)
        DataArray containing the target variable for building the Obs-LE.

    mode_df: pd.DataFrame
        DataFrame containing the climate modes as columns. The index should be 
        a pd.datetime64 index. Rows should contain monthly observations of the
        climate modes. If None, imports modes using 
        process_data.process_climate_modes().

    start_year: str
        First year to include in the Obs-LE. String with four digit year.

    end_year: str
        Last year to include in the Obs-LE. String with four digit year.

    mode_list: list of str
        list containing the names of the climate modes to include.

    lambda_values: list of numeric
         List containing Box-Cox power paramters to optimize over for the
         transformation applied to target_da. Values for the transform are 
         restricted to be positive.

    offset_values: list of numeric
        List containing offsets to be optimized over for shifting target_da before
        apply Box-Cox transform. If there are zeros in the data, offset_values 
        should be positive values such that target_da + offset_values is positive 
        everywhere. Selecting a single value such as [1e-6] works well in practice.

    fit_seasonal: list of bools
        True/False values with length = len(mode_list). True specifies that the
        seasonal cycle in the variance should be maintained in the surrogate modes.
        For most climate modes, fit_seasonal should be True, since there can be
        large differences in variance between months. The trade-off is an increased
        number of iterations before IAAFT converges.

    block_size: int
        The length of time blocks, in months, to use for the moving block bootstrap.
        Must be divisible by 12, so that only whole years are included.

    save_path: str
        Path to the directory in which to save the outputted Obs-LE members and 
        component files. Should end in /. Individual members are saved as 
        netCDF files at: save_path + 'obsLE_member{member #}.nc'

    mode_path: str
        path to the climate modes
    """

    if rng is None:
        rng = np.random.default_rng()

    if mode_df is None and mode_path is None:
        raise ValueError('One of mode_df or mode_path must be specified')
    
    ortho_mode_df = data_proc.build_ortho_mode_df(mode_df=mode_df,
                                                  start_year=start_year,
                                                  end_year=end_year,
                                                  mode_list=mode_list,
                                                  save_path=save_path,
                                                  mode_path=mode_path)

    if forcing_df is not None:
        X = ortho_mode_df.merge(forcing_df, on='time')
    else:
        X = ortho_mode_df
    
    param_ds, _ = optim.optimize_transform(y=y,
                                           X=X,
                                           lambda_values=lambda_values,
                                           offset_values=offset_values,
                                           save_path=save_path)
    
    beta, lm_out = fit.fit_optimized_model(y=y,
                                           X=X,
                                           lam=param_ds['lam'],
                                           offset=param_ds['offset'],
                                           save_path=save_path)

    residuals_da = lm_out['residuals']

    surrogate_modes = resample.create_surrogate_modes(ortho_mode_df,
                                                      fit_seasonal=fit_seasonal,
                                                      n_ens_members=n_ens_members,
                                                      rng=rng,
                                                      save_path=save_path)

    
    build_obsLE(beta_ds=beta, 
                residuals_da=residuals_da,
                block_size=block_size,
                surrogate_modes=surrogate_modes,
                lam=param_ds['lam'],
                offset=param_ds['offset'],
                forcing_df=forcing_df,
                rng=rng,
                save_path=save_path)
